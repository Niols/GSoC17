#+TITLE: Classes
#+AUTHOR: Nicolas `Niols` Jeannerod
#+EMAIL: niols@niols.fr
#+STARTUP: indent

* gov.nasa.jpf
** symbc
*** heap
**** HeapNode
An abstract cell of the heap. Represented by:
- an index on the heap,
- the type of the represented object,
- a symbolic value (of type [[SymbolicInteger]])
- the next [[HeapNode]] on the heap

We can see HeapNodes both as cells of an array (with the index) and as
lists (with the /next/ field).
**** SymbolicInputHeap
An abstract heap. Basically, a list of [[HeapNode]]s (and we keep track of
the size to be able to get it in O(1)).

We have functions like ~getNodesOfType~ and ~getArrayNodesOfType~ that
allow to filter on the type of the [[HeapNode]]s
*** numeric
**** SymbolicInteger
** vm
*** ChoiceGenerator
See [[https://babelfish.arc.nasa.gov/trac/jpf/wiki/devel/choicegenerator][JPF's documentation about choice generators]].
*** ClassInfo
Describes the VM's view of a java class. Contains descriptions of the
static and dynamic fields, declaredMethods, and information relevant
to the class.
 
Note that ClassInfos / classes have three different
construction/initialization steps:

1. construction: recursively via ClassLoaderInfo.getResolvedClassInfo
   -> ClassFileContainer.createClassInfo -> ClassInfo ctor ->
   resolveClass this only creates the ClassInfo object, but it is not
   visible/usable from SUT code yet and hence not observable from
   classLoaded() listeners

2. registration: create StaticElementInfo and add it to the respective
   ClassLoaderInfo statics, then create the java.lang.Class companion
   object in the SUT this makes the ClassInfo usable from SUT code

3. initialization: execute clinit (if the class has one)
 
Note that id/uniqueId are NOT set before registration takes place, and
registration is not automatically performed since listeners/peers
might create ClassInfos internally (e.g. for inspection), which should
not be visible from the SUT or observable by other listeners.
 
Automatic registration from the ClassInfo ctors would require to pass
a ThreadInfo context throughout the whole ClassLoaderInfo/
ClassFileContainer/ClassInfo chain and could lead to false positives
for sharedness based POR, which would record this thread as
referencing even if this is a listener/peer internal request
